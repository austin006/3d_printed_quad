{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Multi-Agent Quadrotor Control with ROS 2","text":""},{"location":"#project-objective","title":"Project Objective","text":"<p>Create a ready-to-fly, LLM-enabled drone swarm with high customizability to provide a platform for multi-agent coordination and AI agent research within the MAGICC Lab</p> <p>Overview</p> <p>This project accomplishes this in three ways:</p> <ul> <li>Custom built quadrotor</li> <li>Multi-agent coordination simulations</li> <li>AI agent integration</li> </ul>"},{"location":"#custom-quadrotor","title":"Custom Quadrotor","text":"<p>Fully assembled quadrotor</p> <p></p> <p>Spherical protection cage</p>"},{"location":"#multi-agent-coordination","title":"Multi-Agent Coordination","text":"<p>Keyboard input commands</p> <p> </p> <p>Waypoint following</p>"},{"location":"#ai-agent-integration","title":"AI Agent Integration","text":"<p>Drone Control Agent</p> <p></p> <p>Natural language command processing</p>"},{"location":"future_work/","title":"Future Work","text":"<p>Last updated August 2025</p>"},{"location":"future_work/#next-steps","title":"Next steps","text":"<ul> <li>Fly in the mocap room </li> <li>Build more quadrotors </li> <li>Reproduce the simulations in the mocap room </li> <li>Expand the capabilities of the AI agent </li> <li>Get a docker container working </li> <li>Fly the quadcopter using a RPi </li> </ul>"},{"location":"future_work/#potential-improvements","title":"Potential Improvements","text":"<ul> <li>Camera integration</li> <li>Upgrade the RPi</li> <li>Improve spherical protection cage</li> <li>Use Jump Point Search as an AI agent tool call</li> <li>Expand AI agent capabilities</li> </ul>"},{"location":"hardware/jetson/","title":"Jetson Nano and Quadrotor Integration","text":"<p>The following documentation gives instructions on how to set up a new Jetson Nano to control a quadrotor with PX4 autopilot. </p>"},{"location":"hardware/jetson/#set-up","title":"Set-up","text":"<p>Follow the detailed instructions provided by PX4: Holybro Pixhawk Jetson Baseboard</p>"},{"location":"hardware/jetson/#pixhawk-jetson-connection","title":"Pixhawk&lt;-&gt;Jetson Connection","text":"<p>The Jetson and Pixhawk are connected using an internal ethernet cable.</p> <p>Set correct IP address for the client if not automatically configured <pre><code>uxrce_dds_client stop\nparam set UXRCE_DDS_AG_IP -1062731775\nparam save\nuxrce_dds_client start\n</code></pre></p> <p>An alternative to setting the parameter is to run client with override flag <pre><code>uxrce_dds_client start -h 192.168.0.1 -p 8888\n</code></pre></p> <p>Check connection from Jetson to Pixhawk <pre><code>ping 192.168.0.3\n</code></pre></p> <p>Pull and run the simplest ROS Jazzy container for ARM64 <pre><code>docker run -it \\\n    --name ros2-jazzy-px4 \\\n    --network host \\\n    --privileged \\\n    -v /dev:/dev \\\n    -v $HOME/workspace:/workspace \\\n    -v /tmp/.X11-unix:/tmp/.X11-unix \\\n    -e DISPLAY=$DISPLAY \\\n    -e QT_X11_NO_MITSHM=1 \\\n    --restart unless-stopped \\\n    ros:jazzy bash\n</code></pre></p>"},{"location":"hardware/jetson/#starting-a-session","title":"Starting a Session","text":""},{"location":"hardware/jetson/#login-to-jetson","title":"Login to Jetson","text":"<ul> <li>ssh command: <code>ssh magicc@192.168.1.83</code> or <code>ssh magicc@ubuntu.local</code></li> <li>username: <code>magicc</code></li> <li>password: <code>magicc</code></li> </ul>"},{"location":"hardware/jetson/#environment-set-up","title":"Environment Set-up","text":"<p>Restart the existing container <pre><code>docker start ros2-jazzy-px4\ndocker exec -it ros2-jazzy-px4 bash\n</code></pre></p> <p>Start the agent</p> <pre><code>MicroXRCEAgent udp4 -p 8888\n</code></pre>"},{"location":"hardware/materials/","title":"Materials","text":""},{"location":"hardware/materials/#parts-and-materials","title":"Parts and Materials","text":"Component Part Flight controller Pixracer Pro Companion Computer Raspberry Pi 4 (CM4) Battery 4s Lipo Battery Power Module PM06 V2 Power Module UBEC 3A 5V/12V Step Down ESCs 20A ESC Brushless Motors AE2207 V2 1860KV Propellors Ethix S5 FPV Propellers Receiver RadioMaster Nano Receiver GPS Micro M10 GPS <p>Go to the detailed spreadsheet</p>"},{"location":"hardware/materials/#spherical-protection-cage","title":"Spherical Protection Cage","text":"<p>Quadrotor protection cage</p> <p></p> <p>Parametric structure of the cage</p> <p>View the CAD files in Onshape</p>"},{"location":"hardware/materials/#parts","title":"Parts","text":"<p>Nano connection board for RPi</p> <p></p> <p>Pixrace Pro flight controller</p> <p></p> <p>RPi IO board</p> <p></p> <p>Assembled RPi with the nano board and heatsink</p> <p></p> <p>3D printed quadrotor frame</p> <p></p> <p>Fully assembled quadrotor</p> <p></p> <p>Quadrotor with the protection cage</p>"},{"location":"hardware/raspberry_pi/","title":"Raspberry Pi and Quadrotor Integration","text":"<p>The following documentation gives a detailed walk through on how to set up a new Raspberry Pi to control a quadrotor with PX4 autopilot. </p>"},{"location":"hardware/raspberry_pi/#important-information","title":"Important Information","text":"<ul> <li>username: magicc </li> <li>password: magicc </li> <li>hostname: raspberrypi.local </li> <li>ssh command with custom username:     <pre><code>ssh magicc@&lt;IP address&gt;\n</code></pre></li> <li>wifi: MAGICC</li> <li>Dynamic IP address: 192.168.1.12      <pre><code>ssh magicc@192.168.1.12 \n</code></pre></li> </ul>"},{"location":"hardware/raspberry_pi/#set-up-the-raspberry-pi","title":"Set Up the Raspberry Pi","text":"<p>Starting requirements: A new Raspberry Pi Compute Module, an IO Board, a small jumper, a micro-USB cable, and a 12V power cable.  </p> <p>End objective: Raspberry Pi running ROS2 on Ubuntu. </p> <p>If you get stuck on steps 1 or 2 refer to this tutorial for help:  How to flash Raspberry Pi OS onto the Compute Module 4 eMMC with usbboot | Jeff Geerling </p>"},{"location":"hardware/raspberry_pi/#1-prepare-to-flash-os-onto-raspberry-pi","title":"1. Prepare to flash OS onto Raspberry Pi","text":"<p>The Raspberry Pi Compute Module 4 used in these instructions has a built in eMMC instead of an SD memory card slot. If your Raspberry Pi requires an SD card, you will download the OS directly onto that and skip to step 3. Otherwise follow these steps to flash an OS onto the eMMC: </p> <ul> <li>Put the small jumper on the IO board. Looking straight down onto the board, it goes in a space at the top left. The location of the two pins is labelled with Fit jumper to disable eMMC Boot. This will disable the eMMC boot and instead allow you to flash an OS onto it. </li> <li>Plug a USB cable from your computer into the IO board at the space labeled USB Slave and connect the board to power. You should see the D1 red light turn on. </li> <li>Download usbboot </li> <li>With the board still powered on and connected to your computer, run the rpiboot executable found in the directory of usbboot. </li> </ul> <p>Success</p> <p>If everything worked correctly, the eMMC storage now behaves just like a microSD card or USB drive that you plugged into your computer. </p>"},{"location":"hardware/raspberry_pi/#2-flash-os-onto-raspberry-pi","title":"2. Flash OS onto Raspberry Pi","text":"<p>We will use an application called Raspberry Pi imager to flash an OS to the eMMC. </p> <ul> <li>Download and open Raspberry Pi Imager</li> <li>Click Choose OS &gt; scroll down &gt; select: <ul> <li>Other general-purpose OS &gt; Ubuntu &gt; Ubuntu Server 22.04.4 LTS (64-bit) for Raspberry Pi </li> </ul> </li> <li>Click Choose Storage and select the newly mounted eMMC. </li> <li>Before writing, click the gear icon (Advanced options) for first-boot config: <ul> <li>Enable SSH: Choose password or SSH key </li> <li>Set hostname (optional) </li> <li>Set Wi-Fi (skip if using Ethernet) </li> </ul> </li> <li>Click Save, then Write to flash Ubuntu onto the eMMC. </li> <li>Disconnect the RPi from your computer and power source and remove the jumper from the pins on the Compute Module IO Board. </li> <li>Connect the RPi to power and it will boot up using the OS on the eMMC. </li> </ul>"},{"location":"hardware/raspberry_pi/#3-connect-to-rpi-via-ssh","title":"3. Connect to RPi via SSH","text":"<p>We will use a computer to remotely ssh into the RPi over Wi-Fi. </p> <ul> <li>Make sure the RPi is powered on and connected to the same network as your computer.</li> <li>From your own machine, run:      <pre><code>ping raspberrypi.local \n</code></pre></li> <li>Once you\u2019ve found the IP address of the Pi, then run:      <pre><code>ssh pi@&lt;IP_ADDRESS&gt; \n</code></pre></li> <li>The default password is raspberry </li> <li>If you set a custom user and password using Raspberry Pi Imager, you will instead run the following and enter your password when prompted.      <pre><code>ssh &lt;user&gt;@&lt;IP_ADDRESS&gt; \n</code></pre></li> </ul>"},{"location":"hardware/raspberry_pi/#4-install-ros2-jazzy-on-the-rpi","title":"4. Install ROS2-jazzy on the RPi","text":"<p>Follow the documentation to install ROS2 on Ubuntu: Ubuntu (deb packages) \u2014 ROS 2 Documentation: Jazzy documentation </p> <p>Note</p> <p>You probably don\u2019t need all the GUI tools on the RPi that come with the Desktop install and you can just perform the ROS-Base install. </p> <ul> <li>Test if ROS is working by running the following in the RPi ssh terminal.      <pre><code>ros2 -h\n</code></pre></li> <li>Don\u2019t forget to add the following lines to your bash file to source your environment. Doing this will automatically source the environment every time you open a new terminal:      <pre><code>source /opt/ros/jazzy/setup.bash \nsource install/setup.bash \n</code></pre></li> </ul>"},{"location":"hardware/raspberry_pi/#ros-communication-between-rpi-and-computer","title":"ROS Communication Between RPi and Computer","text":"<p>Starting requirements: Both a Raspberry Pi and a computer with ROS2. </p> <p>End objective: ROS communication between the RPi and computer. </p> <p>There are multiple ways to run ROS on your computer. The most straightforward way is to run ROS natively in a Linux environment. This will automatically allow network communication between ROS nodes on different devices. Just be sure to set the following variables to the same values on the computer and RPi:  <pre><code>export ROS_DOMAIN_ID=0 \nexport ROS_AUTOMATIC_DISCOVERY_RANGE=SUBNET \n</code></pre> Here are some other options if you don\u2019t have a Linux environment:  </p> <ul> <li>Dual boot </li> <li>A VM </li> <li>Distrobox with Docker or Podman </li> <li>Docker container in WSL </li> </ul> <p>On my Windows laptop, I used Distrobox with Podman in my WSL with mirrored network mode enabled. This worked for me. </p> <p>To do this, first install Linux on Windows with WSL and turn on mirrored network mode. Then navigate to the Installation section in the Distrobox documentation and follow the given steps to install Distrobox. </p>"},{"location":"hardware/raspberry_pi/#send-ros-commands-from-rpi-to-px4","title":"Send ROS Commands from RPi to PX4","text":"<p>Use the following guide to set up the RPi as a companion computer to Pixhawk: </p> <p>Raspberry Pi Companion with Pixhawk</p> <p>This can easily be adapted for other flight controllers running PX4. </p>"},{"location":"hardware/raspberry_pi/#tipsquick-reference","title":"Tips/Quick Reference","text":"<p>Don\u2019t forget to source the ROS 2 environment:  <pre><code>source /opt/ros/jazzy/setup.bash \nsource install/setup.bash \n</code></pre></p> <p>Check status of client:  <pre><code>uxrce_dds_client status \n</code></pre></p> <p>If the client has not started for PX4, you can start it manually (in the PX4 terminal):  <pre><code>uxrce_dds_client start -t serial -d /dev/ttyS3 -b 921600 \n</code></pre></p> <p>Start the agent on the RPi:  <pre><code>sudo MicroXRCEAgent serial --dev /dev/serial0 -b 921600 \n</code></pre></p> <p>Or try:  <pre><code>sudo MicroXRCEAgent serial --dev /dev/ttyAMA0 -b 921600 \n</code></pre></p> <p>To source mavlink virtual environment:  <pre><code>source ~/mavproxy_venv/bin/activate \n</code></pre></p>"},{"location":"hardware/raspberry_pi/#terminal-multiplexer-tmux","title":"Terminal Multiplexer - tmux","text":"<p>It is very helpful to install a terminal multiplexer on the RPi. Use the following commands to install tmux:  <pre><code>sudo apt update  \nsudo apt install tmux \n</code></pre> For quick reference, use this tmux cheatsheet. If you're completely new with tmux, check out A Quick and Easy Guide to tmux. </p>"},{"location":"hardware/raspberry_pi/#key-commands","title":"Key Commands","text":"<ul> <li>Create a new session: <code>tmux new-s &lt;session name&gt;</code></li> <li>Detach from a session: <code>Ctrl+b d</code></li> <li>List available sessions: <code>tmux ls</code></li> <li>Enter an existing session: <code>tmux attach -t &lt;session name&gt;</code></li> <li>End a current session: <code>tmux kill-session -t &lt;session name&gt;</code></li> </ul>"},{"location":"hardware/raspberry_pi/#cross-compiling","title":"Cross Compiling","text":"<p>It can be beneficial to set up cross compiling on a computer so that you don\u2019t have to wait hours for code to compile on the Raspberry Pi. For reference, it took 30 minutes to build the ROS package px4_msgs on the RPi but on a computer it takes 1-3 minutes. </p> <p>The cross_compile tool is no longer supported in ROS.</p> <p>Check out this possible alternative </p>"},{"location":"hardware/raspberry_pi/#extra-guides","title":"Extra Guides","text":"<p>Check the temperature of the RPi: <code>watch -- 'vcgencmd measure_temp</code></p> <p>Guide for setting up RPi as a companion computer. Link</p> <p>Raspberry Pi 4 pinout diagram (pg 17). Link</p> <p>Pixhawk 6c mini pinout guide. Link</p> <p>Guide for uXRCE-DDS (PX4-ROS 2/DDS Bridge). Link</p> <p>ROS2 with PX4. Link</p> <p>Translation node information. Link</p> <p>Jaeyoung Lim\u2019s px4-offboard example. Link</p> <p>Adapted SITL and HITL code. Link</p> <p>Pixracer Pro information. Link</p> <p>MoCap stuff. Link</p>"},{"location":"hardware/transmitter_setup/","title":"Binding the Quadrotor to the Taranis Q X7 Transmitter","text":"<p>Quick Check</p> <p>If it is already binded, no need to do it again (check Step 6)</p>"},{"location":"hardware/transmitter_setup/#1-open-the-radio-setup-menu","title":"1. Open the Radio Setup menu","text":"<p>Figure 1</p> <ul> <li>Press the left-hand button marked with three horizontal lines (see Figure 1)</li> <li>The screen should now display the main MODLESEL page</li> </ul>"},{"location":"hardware/transmitter_setup/#2-navigate-to-model-setup","title":"2. Navigate to Model Setup","text":"<p>Figure 2</p> <ul> <li>Once you reach the MODLESEL page, select the model you want to enter in and press PAGE to reach the page labeled SETUP (see Figure 2)</li> </ul> <p>Preset Pofile</p> <p>For right now, just go to model Lee and bind it to the quadcopter</p>"},{"location":"hardware/transmitter_setup/#3-verify-internal-rf-parameters","title":"3. Verify Internal RF parameters","text":"<p>Figure 3</p> <ul> <li>Scroll all the way down to the Internal RF: Mode, Channel Range, Receiver, and External RF setting. (see Figure 3)</li> <li> <p>Inside the Internal RF section confirm the following:</p> Setting Required Value Mode ON Channel Range CH 1 \u2013 8 Receiver [Bind][Rngh] External RF OFF </li> </ul>"},{"location":"hardware/transmitter_setup/#4-bind-the-receiver","title":"4. Bind the receiver","text":"<p>Figure 4</p> <ul> <li>Highlight Bind and long-press ENT</li> <li>The radio will beep and display Binding\u2026</li> <li>At the same time, if the quadcopter is powered on, it will also beep.</li> </ul>"},{"location":"hardware/transmitter_setup/#5-bind-the-quadcopter-receiver-to-the-transmitter","title":"5. Bind the quadcopter receiver to the Transmitter","text":"<p>Figure 5</p> <p>Info</p> <p>If the receiver\u2019s antenna falls off, don\u2019t worry\u2014it happens often. Just plug it back in.</p> <ul> <li>Disconnect power \u2013 unplug the quadcopter battery.</li> <li>Enter bind mode on the receiver<ul> <li>Locate the small bind button on the upper-left corner of the receiver (see Figure 5)</li> <li>Hold this button and reconnect the battery, then release it once the LED on the receiver starts flashing green</li> </ul> </li> <li>Complete the bind on the radio<ul> <li>On the transmitter, highlight Bind and press ENT</li> <li>When the receiver LED turns solid green, the link is established</li> <li>Press ENT on the transmitter to leave bind mode</li> </ul> </li> </ul>"},{"location":"hardware/transmitter_setup/#6-confirm-a-successful-bind","title":"6. Confirm a successful bind","text":"<ul> <li>Power-cycle both the transmitter and the quadcopter</li> <li>On power-up you should notice:<ul> <li>The transmitter gives a single, clear beep</li> <li>The receiver LED lights solid green</li> </ul> </li> </ul> <p>One-time Setup</p> <p>After a successful bind, the link is stored in memory\u2014each time you power on the transmitter and quadcopter they will reconnect automatically, unless the receiver is re\u2011bound to another radio.</p>"},{"location":"hardware/wiring/","title":"Wiring Connections","text":""},{"location":"hardware/wiring/#power-module","title":"Power Module","text":"PM06 <p>Holybro Micro Power Module (PM06)</p> <p>Information for QGroundControl Power setting:</p> <ul> <li>Voltage Divider: 18.182</li> <li>Amperes per Volt: 36.364</li> </ul> <p></p> <p>Solder the motors to the power module and connect a wire to power the flight controller.</p>"},{"location":"hardware/wiring/#flight-controller","title":"Flight Controller","text":"Pixhawk 6C MiniPixracer Pro <p>Pixhawk 6C Mini Connections:</p> Wire/Device Pixhawk Port Power module Power Motors 1, 2 ,3 4  (I/O PWM OUT [MAIN] in order) Telemetry radio TELEM1 Companion computer TELEM2 Receiver PPM/SBUS RC GPS gps2 <p>Holybro port diagram: Pixhawk 6C Mini Ports | Holybro</p> <p>Pixracer Pro Connections:</p> Wire/Device PixracerPro Port Power module Power Motors 1, 2 ,3 4  (I/O PWM OUT [MAIN] in order) Telemetry radio serial 1 (Telem 1) Companion computer serial 2 (Telem 2) Receiver/Radio rc_input GPS gps2 <p>Resources:</p> <ul> <li>Ardupilot documentation: Pixracer Pro - Plane documentation</li> <li>mRo documentation: Pixracer Pro | User Guides</li> <li>This might help:  PixRacer - Software, Firmware and Connections</li> </ul> <p></p> <p>Top view of PixracerPro (Notice the arrow points forward)</p> <p></p> <p>Bottom view of PixracerPro</p>"},{"location":"hardware/wiring/#companion-computer","title":"Companion Computer","text":"Raspberry Pi <p>The Raspberry Pi needs 5V and 2A. It can't get this from the flight controller because although the voltage is 5V the current is not sufficient.</p> <p>Needs a seperate power supply directly from the battery. Use a UBEC to step down the voltage to power the RPi.</p>"},{"location":"software/docker/","title":"Docker Container","text":"<p>The <code>Dockerfile</code> and <code>devcontainer.json</code> will create the needed environment (as described here) in a Docker container using the VSCode extension called Dev Containers. </p>"},{"location":"software/docker/#set-up-with-docker","title":"Set-up with Docker","text":"<p>I don't think this will work with Docker Desktop becuase of the virtualization that it creates which prevents X11 forwarding for the GUIs. I couldn't get it to function. Instead I used Docker engine without Docker Desktop. </p> <p>Clone this github repo into your desired directory</p> <pre><code>git clone https://github.com/austin006/3d_printed_quad.git\n</code></pre> <p>Navigate to the <code>devcontainer.json</code> file. Make sure to build from the image, not a dockerfile. This is shown below:</p> <pre><code>\"name\": \"PX4 ROS2 Environment\",\n\"image\": \"frostin/ros2-px4\",\n// \"build\": {\n//     \"dockerfile\": \"Dockerfile\"\n// },\n</code></pre> <p>Allow X11 access for any local user (run this on your host machine)</p> <pre><code>xhost +local:\n</code></pre> <p>Be sure to undo xhost permission to re-enable X11 security after finishing with the container</p> <pre><code>`xhost -`\n</code></pre> <p>Install the \"Dev Containers\" extension in VSCode and use the command palette (Ctrl+Shift+P) to select the option \"Dev Containers: Reopen in Container\". This may take a long time to open the container the first time. The container has ROS2 Jazzy, PX4, QGroundControl, and MicroXRCE on a base image of Ubuntu 22.04.</p> <p>You can also pull the Docker image from Docker Hub beforehand and then open the container. </p> <pre><code>docker pull frostin/ros2-px4:latest\n</code></pre> <p>Once you are in the container, make sure you source, build, and source before running any launch files.</p> <pre><code>cd /root/ros2_ws\nsource opt/ros/jazzy/setup.bash\ncolcon build\nsource install/setup.bash\n</code></pre> <p>Test out running a simulation with a launch file</p> <pre><code>ros2 launch px4_offboard offboard_velocity_control.launch.py\n</code></pre>"},{"location":"software/docker/#qgc-path-modifications","title":"QGC Path Modifications","text":"<p>The original code assumes that QGroundControl is located in the home directory (~). The Docker container places it in a directory at <code>/root</code>. You will essentially need to replace <code>~/</code> with <code>/root/</code> for the file path locations of these applications.</p> <p>Alternatively you can simply find the terminal window where QGroundControl attempted to start from and run either of the following commands</p> <pre><code># Launch QGC\nsudo -u user qgroundcontrol\n# or this \n/root/QGroundControl/AppRun\n</code></pre>"},{"location":"software/docker/#gnome-terminal-support","title":"Gnome-Terminal Support","text":"<p>In addition, <code>gnome-terminal</code> is not configured in this Docker container. Instead I use a simpler alternative called <code>xterm</code>. By default the code uses <code>xterm</code> and so you will need to comment/uncomment some lines to switch to <code>gnome-terminal</code> if desired. </p> <p>The two node files to change are located at <code>src/px4_offboard/px4_offboard</code></p> <ul> <li><code>processes.py</code> </li> <li><code>swarm_spawner.py</code> </li> </ul> <p>The launch files to change are all located at <code>src/px4_offboard/launch</code> </p> <ul> <li><code>HITL_offboardvelocity_control.launch.py</code></li> <li><code>offboard_velocity_control.launch.py</code></li> <li><code>swarm_control.launch.py</code></li> <li><code>waypoint.launch.py</code> </li> </ul>"},{"location":"software/docker/#orc-set-up-with-apptainer","title":"ORC Set-up with Apptainer","text":"<p>ROS2 &amp; PX4 Quadrotor Gazebo Simulation Environment. This tutorial explains how to use Apptainer in the BYU ORC server in order to set up a ROS2 &amp; PX4 simulation environment for a quadrotor.</p>"},{"location":"software/docker/#complete-setup-from-scratch","title":"Complete Setup from scratch","text":"<pre><code># Create a directory to host your workspace\nmkdir ros2_workspace\n\n# Copy the px4_offboard package to the workspace\ncd ros2_workspace\nmkdir src\n# From local computer to supercomputer:\nscp Documents/px4_offboard username@ssh.rc.byu.edu:/home/netid/ros2_workspace/src\n\n# Pull Docker container using Apptainer\nmodule load apptainer\napptainer pull ros2_px4_sim.sif docker://frostin/ros2-px4:latest\n\n# On host - allow X11 access\nxhost +local:\n\n# Create a directory overlay\nmkdir -p ./overlay_dirAnother option is to\n\n# Request an interactive compute node\nsalloc --time=1:00:00 -c 12 --mem=16G --gpus=1 --x11\n\n# Source in order to load Apptainer\nsource /etc/profile\nmodule load Apptainer\n\n# Run Apptainer with full GUI support, px4_offboard package mount, and directory overlay\ncd ~/ros2_workspace\napptainer shell \\\n  --cleanenv \\\n  --overlay ./overlay_dir \\\n  --bind \"$XAUTHORITY:$XAUTHORITY\" \\\n  --env DISPLAY=\"$DISPLAY\" \\\n  --env XAUTHORITY=\"$XAUTHORITY\" \\\n  ros2_px4_sim.sif\n\n# Source, build, source the workspace\ncd /root/ros2_ws\nsource opt/ros/jazzy/setup.bash\ncolcon build\nsource install/setup.bash\n\n# Try one of the ROS2 launch files\n# 1 quadrotor, keyboard commands\nros2 launch px4_offboard offboard_velocity_control.launch.py\n# 3 quadrotors, automatic flying to waypoints\nros2 launch px4_offboard multi_waypoint_swarm.launch.py num_vehicles:=3\n# 5 quadrotors, automatic flying to waypoints\nros2 launch px4_offboard multi_waypoint_swarm.launch.py num_vehicles:=5\n\n# Start QGroundControl. \n# An xterm window will open up and try to start QGC but it is not saved in the expected location. \n# Find the xterm window where QGC failed to launch and run the following command:\n/root/QGroundControl/Apprun\n</code></pre> <p>If the launch files didn't work try testing everything separately, follow these steps:</p> <pre><code># Launch 4 terminals\nxterm &amp; xterm &amp; xterm &amp; xterm &amp; \n\n# Launch QGC\nsudo -u user qgroundcontrol\n# or this \n/root/QGroundControl/AppRun\n\n# Launch PX4 with Gazebo\ncd /root/PX4-Autopilot &amp;&amp; make px4_sitl gz_x500\n\n# Start Micro DDS Agent\nMicroXRCEAgent udp4 -p 8888\n\n# Test simple ROS2 Launch file\nros2 launch px4_offboard circle.launch.py\n\n# Final step: In QGC switch the quadrotor to offboard mode and arm the quadrotor.\n</code></pre> <p>Refer to the <code>CL_Control.sh</code> file located at <code>src/px4_offboard/</code> for help with debugging by sending manual commands.</p>"},{"location":"software/docker/#sequential-container-usage","title":"Sequential Container Usage","text":"<p>If the Apptainer environment is already setup and ready to go, use the following instructions for a quicker launch.</p> <pre><code># Request an interactive compute node\nsalloc --time=1:00:00 -c 12 --mem=16G --gpus=1 --x11\n\n# Source in order to load Apptainer\nsource /etc/profile\nmodule load Apptainer\n\n# Run Apptainer with full GUI support, px4_offboard package mount, and directory overlay\ncd ~/ros2_workspace\napptainer shell \\\n  --cleanenv \\\n  --overlay ./overlay_dir \\\n  --bind \"$XAUTHORITY:$XAUTHORITY\" \\\n  --env DISPLAY=\"$DISPLAY\" \\\n  --env XAUTHORITY=\"$XAUTHORITY\" \\\n  ros2_px4_sim.sif\n\n# Source the workspace\ncd /root/ros2_ws\nsource opt/ros/jazzy/setup.bash\nsource install/setup.bash\n\n# Perform simulations. Use any node or launch file to run the ROS2-PX4 Gazebo simulation.\nros2 launch px4_offboard offboard_velocity_control.launch.py\nros2 launch px4_offboard multi_waypoint_swarm.launch.py num_vehicles:=3\n\n# Don't forget to start QGroundControl separately \n/root/QGroundControl/Apprun\n</code></pre>"},{"location":"software/docker/#virtualgl","title":"VirtualGL","text":"<p>Improve framerate by wrapping the simulation with the vglrun command to ensure it utilizes the GPU for rendering. The issue is this currently only works on the login nodes.</p> <p>Make sure you use the docker image with VirtualGL installed. This image is called <code>frostin/ros2-px4-vgl</code></p> <pre><code># Launch the apptainer in a login node\napptainer shell \\\n    --cleanenv \\\n    --overlay ./overlay_dir \\\n    --bind /tmp/.X11-unix:/tmp/.X11-unix \\\n    --bind /dev/dri:/dev/dri \\\n    --bind ./src/px4_offboard:/root/ros2_ws/src/px4_offboard \\\n    --env DISPLAY=$DISPLAY \\\n    --env XDG_RUNTIME_DIR=/tmp \\\n    --nv \\ \n    ros2_px4_vgl_sim.sif\n\n# Source, build, source the workspace\ncd /root/ros2_ws\nsource opt/ros/jazzy/setup.bash\ncolcon build\nsource install/setup.bash\n\n# Wrap the ROS2 launch file with vglrun command\nvglrun ros2 launch px4_offboard offboard_velocity_control.launch.py\n</code></pre> <p>The <code>--nv</code> flag automatically makes the host server's proprietary NVIDIA drivers and libraries available inside your container.</p>"},{"location":"software/docker/#notes","title":"Notes","text":"<ul> <li>The ollama and LangGraph environment for the <code>ai_agent</code> package is not included in the container as of now.</li> </ul>"},{"location":"software/langgraph/","title":"LangGraph Agents","text":"<p>This page explains what LangGraph is and how to use the drone control agent located in the ROS2 package called <code>ai_agent</code>.</p>"},{"location":"software/langgraph/#learn-langgraph","title":"Learn LangGraph","text":"<p>For a full tutorial, use the Introduction to LangGraph created by LangChain Academy</p>"},{"location":"software/langgraph/#drone-control-agent","title":"Drone Control Agent","text":"<p>Drone control agent</p> <p></p> <p>General process of the AI agent</p> <p>Natural language commands are proccessed by the LangGraph agent by invoking LLM calls to the Ollama model. The agent is directed to which ROS2 tool call is needed to correctly control the quadrotor.</p> Name Purpose User Represents natural language commands from a user. LangGraph A library for building stateful, multi-actor applications with LLMs, used here as the framework for the AI agent. Tools A list of ROS2 tools provided to the AI agent to control the quadrotor. Ollama A tool for running large language models (LLMs) locally."},{"location":"software/langgraph/#architecture-overview","title":"Architecture Overview","text":"<p>The agent is designed to work alongside the existing PX4 simulation infrastructure:</p> <pre><code>graph TB \n    subgraph \"Terminal 1\" \n        PROC[processes.py] --&gt; MICRO[MicroXRCEAgent&lt;br/&gt;UDP 8888] \n        PROC --&gt; GAZ[Gazebo PX4 SITL] \n    end \n    subgraph \"Terminal 2 (Optional)\" \n        CTRL[control.py&lt;br/&gt;Keyboard Input] \n    end \n    subgraph \"Terminal 3\" \n        OLLAMA[Ollama Server&lt;br/&gt;LLM Service] \n    end \n    subgraph \"Terminal 4\" \n        USER[User Commands&lt;br/&gt;Natural Language] --&gt; AGENT[agent.py&lt;br/&gt;LangGraph] \n        AGENT --&gt; |LLM Queries| OLLAMA \n        OLLAMA --&gt; |Tool Selection| AGENT \n    end \n    subgraph \"ROS2 Nodes\" \n        CTRL --&gt; |/offboard_velocity_cmd| VEL[velocity_control.py] \n        VEL --&gt; |State Machine| OFF[Offboard Mode] \n        OFF --&gt; |/fmu/in/trajectory_setpoint| MICRO \n        AGENT --&gt; |Direct Commands| TOOLS[drone_tools.py] \n        TOOLS --&gt; |/fmu/in/vehicle_command| MICRO \n        TOOLS --&gt; |/fmu/in/trajectory_setpoint| MICRO \n    end \n    subgraph \"Visualization\" \n        VIZ[visualizer.py] --&gt; RVIZ[RViz2] \n    end \n\n    MICRO &lt;--&gt; GAZ \n    GAZ --&gt; |/fmu/out/*| VIZ \n    GAZ --&gt; |/fmu/out/*| AGENT \n\n    style AGENT fill:#f9f,stroke:#333,stroke-width:4px \n    style TOOLS fill:#f9f,stroke:#333,stroke-width:4px \n    style OLLAMA fill:#f9f,stroke:#333,stroke-width:4px  </code></pre>"},{"location":"software/langgraph/#ai_agent","title":"<code>ai_agent</code>","text":"<p>In this package, the <code>px4_offboard</code> simulation is expanded to interface with an AI Agent allowing for natural language interaction with the quadrotor. This is implented with ROS2, LangChain, LangGraph, and Ollama.</p>"},{"location":"software/langgraph/#set-up","title":"Set-up","text":"<ol> <li> <p>First make sure you have downloaded ollama and pulled the model you wish to use</p> </li> <li> <p>Create a python virtual environment for the required dependencies     <pre><code># Navigate to your ai_agent package\ncd src/ai_agent\n\n# Create a virtual environment\npython3 -m venv venv\n\n# Activate it\nsource venv/bin/activate\n\n# Install dependencies\npip install langgraph langgraph-prebuilt langchain-core  langchain_ollama\n</code></pre></p> </li> </ol>"},{"location":"software/langgraph/#instructions-to-run-the-agent","title":"Instructions to run the agent","text":"<p>To run the agent as a python file (without ROS2) paste the following commands in a terminal (adjust the file paths as needed)</p> <pre><code>cd /ros2_workspaces/3d_printed_quad/src/ai_agent \nsource venv/bin/activate \nsource ~/ros2_workspaces/3d_printed_quad/install/setup.bash \nexport PYTHONPATH=$PYTHONPATH:/ros2_workspaces/3d_printed_quad/src/ai_agent \npython3 ai_agent/agent.py \n</code></pre> <p>To run the agent with the launch files, build the ROS2 workspace and source the environment</p> <pre><code>colcon build\nsource install/setup.bash\n</code></pre> <p>Then you can start the launch file of your choice</p> <pre><code>ros2 launch ai_agent &lt;package_name&gt;\n</code></pre> Launch File Description <code>test_agent.launch.py</code> Launch only the drone control agent <code>offboard_agent_control.launch.py</code> Launch the drone control agent with a Gazebo simulation"},{"location":"software/mocap/","title":"Quadrotor Flight with ROS2 and PX4 - Guide","text":"<p>This page describes how to fly a quadrotor using a motion capture (MOCAP) system. Instructions on how to fly a quadrotor using PX4 in offboard mode through QGroundControl and ROS2.</p>"},{"location":"software/mocap/#mocap-set-up","title":"MOCAP Set-up","text":"<p>Basic overview:</p> <ol> <li>Create an asset</li> <li>Track and publish data via VRPN</li> <li>Start VRPN client node</li> <li>Subscribe to data on ROS2 topic</li> </ol>"},{"location":"software/mocap/#create-an-asset","title":"Create an Asset","text":"<p>See Leon's Tutorial for a detailed walk-through.</p>"},{"location":"software/mocap/#publish-mocap-data","title":"Publish MOCAP Data","text":"<p>See Leon's Tutorial for a detailed walk-through.</p> <p>Note that you only need to enable the VRPN option. NatNet streaming enabled is not required.</p>"},{"location":"software/mocap/#receive-mocap-data","title":"Receive MOCAP Data","text":"<p>See Leon's Tutorial for a detailed walk-through.</p> <p>The data of the asset (position and quaternion) will be published to a ROS2 topic.</p> <p>Install vrpn-mocap package <pre><code>sudo apt install ros-&lt;rosdistro&gt;-vrpn-mocap\n</code></pre></p> <p>Run the mocap node. The server number is something like <code>192.168.1.191</code> <pre><code>ros2 launch vrpn_mocap client.launch.yaml server:=&lt;server number&gt; port:=3883\n# Or try this\nros2 run vrpn_client_ros vrpn_client_node \n</code></pre></p> <p>Check mocap data being published. You must be connected to MAGICC wifi! <pre><code>ros2 topic echo /vrpn_mocap/&lt;asset_name&gt;/pose\n</code></pre></p> <p>Check frequency of messages <pre><code>ros2 topic hz /vrpn_mocap/&lt;asset_name&gt;/pose\n</code></pre></p>"},{"location":"software/mocap/#resources","title":"Resources","text":"<ul> <li>Leon's Tutorial</li> <li>MAGICC Lab Tutorial</li> <li>VRPN Documentation</li> </ul>"},{"location":"software/mocap/#px4-offboard-mode","title":"PX4 Offboard Mode","text":"<p>To fly autonomously via ROS2 commands, the vehicle must be in offboard mode. This requires configuration of PX4 parameters as described below as well as a constant proof of life signal being published from the ROS2 controller program.</p>"},{"location":"software/mocap/#px4-parameters","title":"PX4 Parameters","text":"<ul> <li><code>EKF2_BARO_CTRL</code>: 0</li> <li><code>EKF2_EV_CTRL</code>: 11</li> <li><code>EKF2_GPS_CHECK</code>: 0</li> <li><code>EKF2_GPS_CTRL</code>: 0</li> <li><code>EKF2_EV_DELAY</code>: 0.0ms</li> <li><code>EKF2_HGT_REF</code>: Vision</li> <li><code>EKF2_MAG_CHECK</code>: 0</li> <li><code>EKF2_MAG_TYPE</code>: None</li> <li><code>EKF2_MULTI_IMU</code>: 3</li> <li><code>EKF2_RNG_CTRL</code>: Disable range fusion </li> </ul> <p>Parameters set using QGroundControl</p>"},{"location":"software/mocap/#resources_1","title":"Resources","text":"<ul> <li>PX4 Guide - EKF2 Tuning/Configuration</li> <li>AREAL Hardware Standup Guide - PX4 Parameters for VICON Camera Feedback</li> <li>Github issue - Vicon Position Tracking w/ ROS2</li> <li>Github issue - Flying in position mode with Optitrack motion capture is unstable</li> </ul>"},{"location":"software/mocap/#helpful-commands-for-debugging","title":"Helpful Commands for Debugging","text":""},{"location":"software/mocap/#quick-reference","title":"Quick Reference","text":"<p>Start VRPN Client <pre><code>ros2 launch vrpn_mocap client.launch.yaml server:=192.168.1.201 port:=3883\n</code></pre></p> <p>Login to Jetson <pre><code>ssh magicc@ubuntu.local\n</code></pre></p> <p>Launch QGC <pre><code>./Downloads/QGroundControl-x86_64.AppImage \n</code></pre></p> <p>Clone <code>px4_msgs</code> package <pre><code>git clone https://github.com/PX4/px4_msgs.git\n</code></pre></p>"},{"location":"software/mocap/#ros2-commands","title":"ROS2 Commands","text":"<p>Check the published mocap data <pre><code>ros2 topic echo /vrpn_mocap/x650_quad/pose\nros2 topic hz /vrpn_mocap/x650_quad/pose\n</code></pre></p> <p>Check the position data passed to PX4 <pre><code>ros2 topic echo /fmu/in/vehicle_visual_odometry\nros2 topic hz /fmu/in/vehicle_visual_odometry\n</code></pre></p> <p>Check odometry data published by EKF2 <pre><code>ros2 topic echo /fmu/out/vehicle_odometry\nros2 topic hz /fmu/out/vehicle_odometry\n</code></pre></p> <p>Rebuild the <code>mocap_px4_bridge</code> package <pre><code>colcon build --packages-select mocap_px4_bridge\nsource install/setup.bash \nros2 run mocap_px4_bridge mocap_px4_bridge\n</code></pre></p> <p>Playback saved mocap data from a rosbag <pre><code>ros2 bag play mocap_data/\n</code></pre></p>"},{"location":"software/mocap/#px4-console-debugging","title":"PX4 Console Debugging","text":"<p>This is in the MAVLink Console <pre><code># Check flight status\ncommander status\n# See the recent data received on any PX4 topic\nlistener vehicle_visual_odometry\nlistener vehicle_status\nlistener vehicle_odometry\nlistener estimator_status\nlistener vehicle_local_position\n# Manage ekf2 \nekf2 stop\nekf2 start\nekf2 status\n# Check PX4's internal time\nuorb top -1 vehicle_visual_odometry\n# Other checks\nlistener estimator_innovations\nlistener estimator_innovation_variances\nlistener estimator_status_flags\nlistener sensor_combined\ncommander check\n</code></pre></p>"},{"location":"software/ollama/","title":"LLMs on a Companion Computer","text":""},{"location":"software/ollama/#ollama","title":"Ollama","text":"<p>Ollama is a framework that simplifies running large language models (LLMs) locally on your computer, allowing for privacy and control over your data and interactions with the models.</p> <p>Download ollama and see the quickstart docs for basic commands</p> <p>Download ollama for Linux: <pre><code>curl -fsSL https://ollama.com/install.sh | sh\n</code></pre></p>"},{"location":"software/ollama/#key-commands","title":"Key Commands","text":"<pre><code>ollama run &lt;model name&gt;\nollama pull &lt;model name&gt;\nollama rm &lt;model name&gt;\nollama ls\nollama ps\nollama stop\nollama show\n</code></pre>"},{"location":"software/ollama/#llm-choice","title":"LLM Choice","text":"<p>Not all models support tool calling. See the Ollama list of the models that currently support tool calling.</p>"},{"location":"software/ollama/#gemma-3","title":"Gemma 3","text":"<p>See the Gemma3 models available with Ollama. Gemma 3 performance on the RPi was tested in June 2025.</p>"},{"location":"software/ollama/#gemma-3-model-performance-on-raspberry-pi-compute-module-4","title":"Gemma 3 Model Performance on Raspberry Pi Compute Module 4","text":"<p>Hardware: Raspberry Pi Compute Module 4 (8GB RAM, 32GB eMMC Storage) Tool: Ollama</p> Model Prompt Total Duration Load Duration Prompt Eval Count Prompt Eval Duration Prompt Eval Rate Eval Count Eval Duration Eval Rate gemma3:1b-it-qat \"Why is the sky blue?\" 2m 25.26s 122.09ms 16 tokens 1.01s 15.82 tokens/s 452 tokens 2m 24.13s 3.14 tokens/s \"Write a python function to average all the values in an array.\" 3m 16.13s 116.17ms 504 tokens 35.89s 14.04 tokens/s 491 tokens 2m 38.26s 3.10 tokens/s gemma3:4b-it-qat \"Why is the sky blue?\" 12m 12.76s 117.63ms 16 tokens 2.03s 7.87 tokens/s 618 tokens 12m 10.60s 0.85 tokens/s \"Write a python function to average all the values in an array.\" Incomplete* - - - - - - - gemma3:1b \"Why is the sky blue?\" 2m 2.10s 172.88ms 15 tokens 1.43s 10.51 tokens/s 468 tokens 2m 0.50s 3.88 tokens/s \"Write a python function to average all the values in an array.\" 2m 31.24s 161.40ms 505 tokens 2.06s 245.14 tokens/s 567 tokens 2m 28.91s 3.81 tokens/s gemma3:4b \"Why is the sky blue?\" 8m 26.39s 166.98ms 15 tokens 0.74s 20.16 tokens/s 651 tokens 8m 25.48s 1.29 tokens/s \"Write a python function to average all the values in an array.\" 10m 29.78s 175.75ms 688 tokens 8.34s 82.51 tokens/s 755 tokens 10m 21.12s 1.22 tokens/s gemma3n:e2b \"Why is the sky blue?\" 3m 11.06s 562.89ms 15 tokens 3.26s 4.60 tokens/s 372 tokens 3m 7.24s 1.99 tokens/s \"Write a python function to average all the values in an array.\" 4m 27.42s 444.59ms 22 tokens 4.85s 4.54 tokens/s 515 tokens 4m 22.11s 1.96 tokens/s <p>Test was stopped prematurely due to excessive processing time and overheating of the Raspberry Pi (70\u00b0C+).</p>"},{"location":"software/overview/","title":"Software Overview","text":""},{"location":"software/overview/#full-set-up","title":"Full Set-up","text":"<p>Layout of the whole software system</p> Name Purpose Docker A platform for developing, shipping, and running applications in containers. Fast DDS A high-performance, open-source C++ implementation of the Data Distribution Service (DDS) standard, serving as the default middleware for ROS2. Gazebo A powerful 3D robotics simulator that allows for the simulation of robots in complex indoor and outdoor environments. Keyboard Input A ROS2 node that accepts keyboard input commands and converts them into quadrotor flight commands. LangGraph A library for building stateful, multi-actor applications with LLMs, used here as the framework for the AI agent. MavLink A lightweight messaging protocol for communicating with small unmanned vehicles. MicroXRCE-DDS A client-server protocol that enables resource-constrained devices (microcontrollers) to communicate with a DDS network. Ollama A tool for running large language models (LLMs) locally. PX4 An open-source flight control software for drones and other unmanned vehicles. QGroundControl An open-source ground control station (GCS) for MAVLink-based drones, providing flight control and mission planning. Quadrotor The physical unmanned aerial vehicle (UAV) with four rotors. ROS2 Robot Operating System 2, a set of software libraries and tools for building robot applications. RViz A 3D visualization tool for ROS that displays sensor data, robot models, and algorithm outputs. Tools A list of ROS2 tools provided to the AI agent to control the quadrotor. User Represents natural language commands from a user. Waypoints A ROS2 node that converts a provided list of waypoints to a trajectory path for a quadrotor flight."},{"location":"software/overview/#fitting-in-the-software","title":"Fitting in the Software","text":"<p>Follow along with the diagrams step by step to see how each piece builds upon the previous. This will allow for a natural, intuitive understanding if you are not familiar with many of the tools presented.</p>"},{"location":"software/overview/#transmitter","title":"Transmitter","text":"<p>Connection between transmitter, PX4, and quadrotor</p>"},{"location":"software/overview/#ros-2","title":"ROS 2","text":"<p>ROS 2 is an open-source framework designed to simplify the development of robotics software</p>"},{"location":"software/overview/#microxrce-dds","title":"MicroXRCE-DDS","text":"<p>MicroXRCE-DDS creates a communication bridge between ROS2 and PX4</p>"},{"location":"software/overview/#gazebo","title":"Gazebo","text":"<p>Gazebo and RViz are used to simulate quadrotor flight</p>"},{"location":"software/overview/#advanced-control","title":"Advanced Control","text":"<p>ROS 2 provides framework to perform complex tasks and customize quadrotor control</p>"},{"location":"software/overview/#ai-agent","title":"AI Agent","text":"<p>An AI Agent can invoke LLMs and call tools to process natural language flight commands</p>"},{"location":"software/qgroundcontrol_setup/","title":"QGroundControl","text":"<p>Follow these steps once the quadcopter is assembled and ready to fly.</p>"},{"location":"software/qgroundcontrol_setup/#1-update-firmware","title":"1. Update firmware","text":"<ul> <li>Update the framework when using the Holybro Telemetry Radio Modules</li> </ul> <p>Holybro Telemetry Radio Module</p> <ul> <li>Always flash the same firmware to both telemetry radios (air\u2011side and ground\u2011side) to ensure they communicate properly (make sure both of them have the same frequency)</li> <li>In QGroundControl, open Vehicle Setup\u202f\u2013\u25b8\u202fFirmware, select each radio in turn, and click \"Update\"</li> <li>Once updated, the radio link lets you monitor Pixhawk data wirelessly\u2014no USB cable required</li> </ul> <p></p> <p>QGroundControl homescreen</p> <p></p> <p>Firemware page</p>"},{"location":"software/qgroundcontrol_setup/#2-sensors","title":"2. Sensors","text":"<p>Click on compass and perform the callibration of the flight controller.</p>"},{"location":"software/qgroundcontrol_setup/#3-radio","title":"3. Radio","text":"<p>Callibrate your transmitter.</p>"},{"location":"software/qgroundcontrol_setup/#4-flight-modes","title":"4. Flight Modes","text":"<ul> <li>Set up the controls of transmitter for flying mode and arm and unarmed</li> <li>In QGroundControl, open Vehicle Configuration\u2013\u25b8\u202fFlight Modes</li> </ul> <p>Correct flight mode settings</p>"},{"location":"software/qgroundcontrol_setup/#flight-mode-settings-orange-box","title":"Flight Mode Settings (orange box)","text":"<ul> <li>Maps the main mode switch on your transmitter (usually Channel\u202f5) to up to six flight modes - each row corresponds to a PWM \u201cslot\u201d on that channel</li> <li>When you flip the mode switch, Pixhawk jumps to the mode shown here</li> <li>Flight mode<ul> <li>Stabilized - Manually flying mode</li> <li>Position - Uses GPS and sensors to hold both position and altitude</li> <li>Mission - Fully autonomous flights where the drone follows a waypoint list you uploaded in QGroundControl</li> </ul> </li> </ul>"},{"location":"software/qgroundcontrol_setup/#switch-settings-red-box","title":"Switch Settings (red box)","text":"<ul> <li>Lets you dedicate additional transmitter switches to one\u2011touch functions -each drop\u2011down assigns an RC channel to a specific action</li> <li>Here, right now we only need to switch between Arm/Disarms, that's why we leave most of them Unassigned</li> <li>Term  <ul> <li>Arm -&gt; Tells the flight\u202fcontroller that all pre\u2011flight checks have passed and it is safe to spin the motors. Throttle commands are now live. You have to switch to Arm mode before everytime you fly. </li> <li>Disarm -&gt; cuts power to the ESCs so the motors cannot spin, even if you bump the throttle.</li> </ul> </li> </ul>"},{"location":"software/qgroundcontrol_setup/#channel-monitor-yellow-box","title":"Channel Monitor (yellow box)","text":"<ul> <li>Helps you verify that the correct switch moves the correct channel and that its endpoints sit in the allowed ranges</li> <li>Flip a switch and watch the white dot move</li> <li>If the dot lands in the wrong slot, adjust the transmitter\u2019s channel order or end\u2011points</li> </ul>"},{"location":"software/qgroundcontrol_setup/#5-power","title":"5. Power","text":"<p>Need to put in the right values depending on what power module you are using.</p> <p>PixracerPro QGroundControl Power setting:</p> <ul> <li>Voltage Divider: 18.182</li> <li>Amperes per Volt: 36.364</li> </ul>"},{"location":"software/qgroundcontrol_setup/#6-actuators","title":"6. Actuators","text":"<p>Use this to test if all the motors are working. Double check that two motors are spinning clockwise and the other two are spinning counter-clockwise. </p>"},{"location":"software/ros2/","title":"ROS2 and Gazebo","text":"<p>This page explains how to get started using ROS2 to fly the quadrotor and perform simulations</p>"},{"location":"software/ros2/#learn-ros2","title":"Learn ROS2","text":"<p>There are lots of available resources for learning ROS2</p> <ul> <li>MAGICC Lab tutorials</li> <li>ROS 2 from Scratch by Edouard Renard</li> <li>ROS2 Official tutorials</li> <li>ROS2 Docker tutorial</li> <li>ROS2 For Beginners</li> </ul>"},{"location":"software/ros2/#learn-gazebo","title":"Learn Gazebo","text":"<p>As long as Gazebo is installed properly, it should work pretty well and easily with ROS2</p> <ul> <li>MAGICC Lab tutorials</li> <li>Multi-Vehicle Simulation with Gazebo</li> <li>Gazebo Simulation</li> <li>ros_gz_project_template (A template project integrating ROS 2 and Gazebo simulator)</li> </ul>"},{"location":"software/ros2/#multi-quadcopter-control-with-px4-and-ros2","title":"Multi-Quadcopter Control with PX4 and ROS2","text":"<p>The following set-up information explains how to use the code in the <code>src</code> directory of this repository. It explains how to set up the proper environment and utilize the provided ROS2 package. The <code>src</code> directory is designed to be the source directory for a standard ROS2 workspace. Each subdirectory is a seperate package with different purposes. </p> <p>An overview of each package is provided as well as instructions for setting up the environment.</p> <ul> <li><code>px4_offboard</code></li> <li><code>ai_agent</code></li> <li>set-up</li> </ul>"},{"location":"software/ros2/#px4_offboard","title":"<code>px4_offboard</code>","text":"<p>Multi-agent quadrotor simulation using ROS2, PX4, Gazebo, QGroundControl, MicroXRCEAgent, and RViz.</p> <p>Much of the intial code is based off work from: </p> <ul> <li>Jaeyoung Lim's Offboard example</li> <li>ARK Electronics' example</li> </ul> <p>I've used their examples to expand functionalities such as multi-agent control. It may be helpful to start with their examples first.</p>"},{"location":"software/ros2/#explanation-of-launch-files","title":"Explanation of launch files","text":"Launch File Description <code>circle.launch</code> Launch a quadrotor to fly in a circle <code>square.launch</code> Launch a quadrotor to fly in a square <code>waypoint.launch</code> Launch a quadrotor to fly to a set of user-supplied waypoints <code>HITL_offboard_velocity_control.launch</code> Run on a real quadrotor for keyboard control <code>multi_waypoint_swarm.launch</code> Launch a swarm of quadrotors to follow supplied waypoints <code>offboard_velocity_control.launch</code> Launch a quadrotor controlled by keyboard inputs <code>swarm_control.launch</code> Launch a swarm of quadrotors to be controlled by keyboard inputs"},{"location":"software/ros2/#run-a-launch-file","title":"Run a launch file","text":"<p>Make sure you have built the ROS2 workspace and sourced the environment</p> <pre><code>colcon build\nsource install/setup.bash\n</code></pre> <p>Then you can start the launch file of your choice (assuming have already completed the set-up for PX4, Gazebo, MicroXRCEAgent, and the ROS2 workspace)</p> <pre><code>ros2 launch px4_offboard &lt;package_name&gt;\n</code></pre> <p>Several launch files support multiple vehicles with a launch configuration parameter called 'num_vehicles'</p> <pre><code>ros2 launch px4_offboard multi_waypoint_swarm.launch.py num_vehicles:=3\n</code></pre>"},{"location":"software/ros2/#notes-on-circlelaunchpy-and-squarelaunchpy-launch-files","title":"Notes on <code>circle.launch.py</code> and <code>square.launch.py</code> launch files","text":"<p>These launch files do not call on the <code>processes.py</code> node. Therefore you need to start the different processes manually in different terminals.</p> <p>Terminal 1 <pre><code>ros2 launch px4_offboard circle.launch.py\n</code></pre> Terminal 2 <pre><code>MicroXRCEAgent udp4 -p 8888\n</code></pre> Terminal 3 <pre><code>cd ~/PX4-Autopilot &amp;&amp; make px4_sitl gz_x500\n</code></pre> Terminal 4 <pre><code>cd ~/QGroundControl &amp;&amp; ./QGroundControl.AppImage\n</code></pre></p> <p>After everything has started, arm the drone in QGroundControl and switch it into offboard mode.</p>"},{"location":"software/ros2/#set-up","title":"Set-up","text":"<p>A faster, simpler alternative to the following steps is to use a Docker container. See this page for instructions to Set-up with Docker</p>"},{"location":"software/ros2/#install-px4-autopilot","title":"Install PX4 Autopilot","text":"<p>To Install PX4 run this code  <pre><code>git clone https://github.com/PX4/PX4-Autopilot.git --recursive\n</code></pre></p> <p>Run this script in a bash shell to install everything</p> <pre><code>bash ./PX4-Autopilot/Tools/setup/ubuntu.sh\n</code></pre> <p>You will now need to restart your computer before continuing</p>"},{"location":"software/ros2/#install-ros2-jazzy","title":"Install ROS2 Jazzy","text":"<p>To install ROS2 Jazzy follow the steps here</p>"},{"location":"software/ros2/#install-dependencies","title":"Install Dependencies","text":"<p>Install Python dependencies as mentioned in the PX4 Docs with this code</p> <pre><code>pip3 install --user -U empy pyros-genmsg setuptools\n</code></pre>"},{"location":"software/ros2/#build-micro-dds","title":"Build Micro DDS","text":"<p>As mentioned in the PX4 Docs run this code in order to build MicroDDS on your machine</p> <pre><code>git clone https://github.com/eProsima/Micro-XRCE-DDS-Agent.git\ncd Micro-XRCE-DDS-Agent\nmkdir build\ncd build\ncmake ..\nmake\nsudo make install\nsudo ldconfig /usr/local/lib/\n</code></pre>"},{"location":"software/ros2/#clone-in-repo-and-packages","title":"Clone in Repo and Packages","text":"<p>Run this code to clone the repo</p> <pre><code>git clone https://github.com/austin006/3d_printed_quad.git\n</code></pre> <p>We need the px4_msgs package. Our ROS2 nodes rely on the message definitions in this package in order to communicate with PX4. Read here for more information.</p> <p>Be sure you're in the src directory of the workspace and run this code to clone in the px4_msgs repo</p> <pre><code>cd src\ngit clone https://github.com/PX4/px4_msgs.git -b release/1.15\n</code></pre> <p>For some reason I couldn't get this to work in ROS2 Jazzy without also including <code>px4_msgs_old</code> and the <code>translation_node</code> packages. To copy these packages, make sure you are in your workspace directory and have installed PX4-Autopilot in your root directory. Run the following code</p> <pre><code>~/PX4-Autopilot/Tools/copy_to_ros_ws.sh .\n</code></pre> <p>Clone in all required packages before building the workspace</p>"},{"location":"software/ros2/#build-the-workspace","title":"Build the Workspace","text":"<p>Source the ROS2 installation, build the workspace within the workspace directory (not in <code>src</code>), and source the workspace</p> <pre><code>source /opt/ros/jazzy/setup.bash\ncolcon build\nsource install/setup.bash\n</code></pre> <p>Your workspace directory should now look similar to the following</p> <pre><code>.\n\u251c\u2500\u2500 .github\n\u251c\u2500\u2500 build\n\u251c\u2500\u2500 docs\n\u251c\u2500\u2500 install\n\u251c\u2500\u2500 log\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 other_ros_packages\n\u2502   \u251c\u2500\u2500 px4_offboard\n\u2502   \u251c\u2500\u2500 px4_msgs\n\u2502   \u251c\u2500\u2500 px4_msgs_old\n\u2502   \u251c\u2500\u2500 translation_node\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 README.md\n</code></pre>"},{"location":"software/ros2/#enable-symlinks","title":"Enable symlinks","text":"<p>This is very helpful as you don't have to build and source every time you edit the code. </p> <pre><code># 1. Initial build (use symlinks)\ncolcon build --symlink-install\n\n# 2. Source once\nsource install/setup.bash\n\n# 3. Edit code\nvim src/my_pkg/src/main.py\n\n# 4. Rebuild only one package (needed only for C++)\ncolcon build --packages-select my_pkg\n\n# 5. Re-run\nros2 run my_pkg node_name\n</code></pre>"},{"location":"software/ros2/#running-the-code","title":"Running the code","text":"<p>Follow the instructions for each package to run the code</p>"}]}